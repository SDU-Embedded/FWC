#!/opt/rakudo-star-2017.01/bin/perl6
use v6.c;

use MONKEY-SEE-NO-EVAL; 

# Perl5 compatibility
use Inline::Perl5;

my $p5 = Inline::Perl5.new;
$p5.use('NetAddr::IP');
$p5.use('IPTables');



sub load_protocol($protocol){
	state %protocol_definitions;

	if not %protocol_definitions{$protocol}:exists {
		my $proto_file = "protos/" ~ $protocol ~ ".proto";
		say "Proto to load: ", $proto_file;
		if $proto_file.IO ~~ :e {
	        	my @proto = lines $proto_file.IO; # Slurp!

			my @iptableLines =  grep(/^\s*iptables/, @proto); # should be combined with map below.
			@iptableLines = map {$_ ~~ s/^\s*iptables\s*//; $_}, @iptableLines;

#			say join(",",@iptableLines);
#			say "Number of elements: ", @iptableLines.elems;

			%protocol_definitions{$protocol} := @iptableLines;
		} else {
		    say "Protocol $protocol does not exist";
		    return ();
		}
	} else {
#		say "Protocol \"$protocol\"already loaded";
	}	
#	say "out:", join(",",%protocol_definitions{$protocol});
	return %protocol_definitions{$protocol};
}

class IptablesGenerator {
	has %!Zones; 
	has %!Rules;  

	has $!FileHandle;

	submethod BUILD(:%!Zones, :%!Rules, :$Filename = "Iptables.sh") {
		$!FileHandle = open $Filename, :w;	
		$!FileHandle.print("#!/bin/bash\n");
		$!FileHandle.print("#     This file is autogenerated by FWC - Do not edit this file by hand\n\n");
	}

	submethod GenerateRules {
		for %!Rules.kv -> $from, @rules {
                	my $FromIp = $p5.invoke('NetAddr::IP','new', %!Zones{$from}{'ip'} ~ '/' ~ %!Zones{$from}{'cidr'});
                	for @rules -> $rule {
                	        my ($to, %options) = $rule.kv;
                	        my $protocol = %options<Protocol>;

                	        my ($name, $alias, $port, $proto) = $p5.call("CORE::getservbyname", $protocol, 'tcp');
                	        my $ToIp = $p5.invoke('NetAddr::IP','new',%!Zones{$to}{'ip'} ~ '/' ~ %!Zones{$to}{'cidr'});

				say "Create for proto: $protocol from $FromIp to $ToIp";
				my @content = load_protocol($protocol);
				if @content.elems > 0 {
					say "Loaded protocol: ", @content.elems,"\n";
					my @parsed_objs = map { $p5.invoke("IPTables::Rule","parser",split(' ', $_ ))}, @content;
					for @parsed_objs -> $obj {
						my $test = $obj.clone1(CHAIN=>"awesome");
						$!FileHandle.print($test.argvec(1) ~ "\n");
					}
				}

				# Substitute
				# Generate rule
				# Write to $!filehandle

			}
		}
	}

	submethod GenerateUniqueChainNames {
		my %FromTo;

		# Generate an unique list of FromZone-ToZone, so that even though we use the same FromZone-ToZone more than once, it will only appear in the iptables-script once.
		for %!Rules.kv -> $from, @rules {
			for @rules -> $rule {
	                        my $to = $rule.key;
				%FromTo{$from ~ "-" ~ $to} = 1;
				%FromTo{$to ~ "-" ~ $from} = 1;
			}
		}


		$!FileHandle.print("#-------- Create zones ------\n");
		for %FromTo.keys -> $FromTo {
			$!FileHandle.print("iptables -N $FromTo\n");
		}
		$!FileHandle.print("#-------- End create zones ------\n\n");
	}

	submethod GenerateChains {
		my %ToBeCreatedNewLocal;
		my %ToBeCreatedAddLocal;

		my %ToBeCreatedNewRemote;
		my %ToBeCreatedAddRemote;

		for %!Rules.kv -> $from, @rules {
                	my $FromIp = $p5.invoke('NetAddr::IP','new', %!Zones{$from}{'ip'} ~ '/' ~ %!Zones{$from}{'cidr'});
                	for @rules -> $rule {
                	        my ($to, %options) = $rule.kv;
                	        my $protocol = %options<Protocol>;

                	        my ($name, $alias, $port, $proto) = $p5.call("CORE::getservbyname", $protocol, 'tcp');
                	        my $ToIp = $p5.invoke('NetAddr::IP','new',%!Zones{$to}{'ip'} ~ '/' ~ %!Zones{$to}{'cidr'});

#	         	        say "%FwcZones{$from}{'ip'} DNAT to %!Zones{$to}{'ip'}, port $port" unless $ToIp.contains($FromIp);
                	        if %!Zones{$to}{'islocal'} !~~ /true/ {
                	                %ToBeCreatedAddRemote{"\$!FileHandle.print\(\"iptables -A FORWARD -i %!Zones{$from}{'interface'} -s $FromIp -o %!Zones{$to}{'interface'} -d $ToIp -j {$from}-{$to}\\n\"\)"} = 1;
                	                %ToBeCreatedAddRemote{"\$!FileHandle.print\(\"iptables -A FORWARD -i %!Zones{$to}{'interface'} -s $ToIp -o %!Zones{$from}{'interface'} -d $FromIp -j {$to}-{$from}\\n\"\)"} = 1;

                	        } else {
                	                %ToBeCreatedAddLocal{"\$!FileHandle.print\(\"iptables -A INPUT -i %!Zones{$to}{'interface'} -d $ToIp -j {$from}-{$to}\\n\"\)"} = 1;
                	                %ToBeCreatedAddLocal{"\$!FileHandle.print\(\"iptables -A OUTPUT -o %!Zones{$to}{'interface'} -s $ToIp -j {$to}-{$from}\\n\"\)"} = 1;
                	        }
                	}
        	}


		$!FileHandle.print("#-------- Add zone-chains(Remote) to chains ------\n");
		for %ToBeCreatedAddRemote.keys -> $line {
			EVAL($line);
		}
		$!FileHandle.print("#-------- End add zone-chains(Remote) to chains ------\n\n");



		$!FileHandle.print("#-------- Add zone-chains(Local) to chains ------\n");
		for %ToBeCreatedAddLocal.keys -> $line {
			EVAL($line);
		}
		$!FileHandle.print("#-------- End add zone-chains(Local) to chains ------\n\n");

	}
	submethod GenerateSpoofRules {
		my $file = "template/spoof.tmpl";
		my $spoofTemplate = try slurp($file);
                if ($!) {
                     note "Unable to open and read file, $file, $!";
                }

		$spoofTemplate ~~ s:g/\$IF\$/foo-interface/;
		$spoofTemplate ~~ s:g/\$SOURCE_IP\$/cool-ip2-cool/;

		$!FileHandle.print("#------------ Spoof - only allow certain ips to send and receive packets\n");
		$!FileHandle.print($spoofTemplate);
		$!FileHandle.print("#------------ End spoof - only allow certain ips to send and receive packets\n");
	}
	submethod GenerateClientServerProtoChains{
		my @ToBeCreated;
		my %UniqChainNames;

		$!FileHandle.print("#-------- Create proto-client/server chains ------\n");
		for %!Rules.kv -> $from, @rules {
                	my $FromIp = $p5.invoke('NetAddr::IP','new', %!Zones{$from}{'ip'} ~ '/' ~ %!Zones{$from}{'cidr'});
                	for @rules -> $rule {
                	        my ($to, %options) = $rule.kv;
                	        my $protocol = %options<Protocol>;

	                        my ($name, $alias, $port, $proto) = $p5.call("CORE::getservbyname", $protocol, 'tcp');
	                        my $ToIp = $p5.invoke('NetAddr::IP','new',%!Zones{$to}{'ip'} ~ '/' ~ %!Zones{$to}{'cidr'});

				$alias = $protocol if $alias eq 0; # some alias doesn't exist, just use name given in policy-file

				%UniqChainNames{"{$alias}-s2c"} = 1;
				%UniqChainNames{"{$alias}-c2s"} = 1;

				@ToBeCreated.append( "\$!FileHandle.print\(\"iptables -A {$from}-{$to} -j {$alias}-c2s\\n\"\)" );
				@ToBeCreated.append( "\$!FileHandle.print\(\"iptables -A {$to}-{$from} -j {$alias}-s2c\\n\");" );
			}
		 }

		for %UniqChainNames.keys -> $chainNames {
			$!FileHandle.print("iptables -N $chainNames\n");
		}

		$!FileHandle.print("#-------- End create proto-client/server chains ------\n\n");

		$!FileHandle.print("#-------- Append protos to proto-client/server chains ------\n");
		for @ToBeCreated -> $rule {
			 EVAL($rule);
		}
		$!FileHandle.print("#-------- End append protos to proto-client/server chains ------\n");

	}
}
