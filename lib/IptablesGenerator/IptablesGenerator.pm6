#!/opt/rakudo-star-2017.01/bin/perl6
use v6.c;

use MONKEY-SEE-NO-EVAL; 

# Perl5 compatibility
use Inline::Perl5;

my $p5 = Inline::Perl5.new;
$p5.use('NetAddr::IP');
$p5.use('IPTables');



sub load_protocol($protocol){
	state %protocol_definitions;

	if not %protocol_definitions{$protocol}:exists {
		my $proto_file = "protos/" ~ $protocol ~ ".proto";
		say "Proto to load: ", $proto_file;
		if $proto_file.IO ~~ :e {
	        	my @proto = lines $proto_file.IO; # Slurp!

			my @iptableLines =  grep(/^\s*iptables/, @proto); # should be combined with map below.
			@iptableLines = map {$_ ~~ s/^\s*iptables\s*//; $_}, @iptableLines;

			%protocol_definitions{$protocol} := @iptableLines;
		} else {
		    say "Protocol $protocol does not exist";
		    return ();
		}
	} else {
#		say "Protocol \"$protocol\"already loaded";
	}	
#	say "out:", join(",",%protocol_definitions{$protocol});
	return %protocol_definitions{$protocol};
}

class IptablesGenerator {
	has %!Zones; 
	has %!Rules;  

	has $!FileHandle;

	submethod BUILD(:%!Zones, :%!Rules, :$Filename = "Iptables.sh") {
		$!FileHandle = open $Filename, :w;	
		$!FileHandle.print("#!/bin/bash\n");
		$!FileHandle.print("#     This file is autogenerated by FWC - Changes will be overwritten\n\n");
		$!FileHandle.print("UNPRIV=1024:65000;\n\n");
	}

	submethod GenerateRules {
		my @rules_to_file;
		my %UniqProtocols;
		for %!Rules.kv -> $from, @rules {
                	my $FromIp = $p5.invoke('NetAddr::IP','new', %!Zones{$from}{'ip'} ~ '/' ~ %!Zones{$from}{'cidr'});
                	for @rules -> $rule {
                	        my ($to, %options) = $rule.kv;
                	        my $protocol = %options<Protocol>;

                	        my ($name, $alias, $port, $proto) = $p5.call("CORE::getservbyname", $protocol, 'tcp');
                	        my $ToIp = $p5.invoke('NetAddr::IP','new',%!Zones{$to}{'ip'} ~ '/' ~ %!Zones{$to}{'cidr'});

				say "Create for proto: $protocol from $FromIp to $ToIp";
				%UniqProtocols{$protocol} = "alias" => $alias, "options" => %options, "port" => $port;
			}
		}

		say %UniqProtocols;
		for %UniqProtocols.kv -> $protocol,@values_tmp {
			my %values = @values_tmp; # To hash from list
#
#			print "port: ", $values{"port"}
			my @content = load_protocol($protocol);
			if @content.elems > 0 {
				my $alias = %values{"alias"};
				my $port = %values{"port"};
				say "Loaded protocol: ", @content.elems,"\n";
				my @parsed_objs = map { $p5.invoke("IPTables::Rule","parser",split(' ', $_ ))}, @content;
				for @parsed_objs -> $obj {
					my $test;
					if "SPORT" eq any($obj.vars()) {
						$test = $obj.clone1(CHAIN=> "{$alias}-c2s", SPORT => $port);
	                                        @rules_to_file.push: $test.argvec(1);
					} elsif ( "DPORT" eq any( $obj.vars() ) ) {
						$test = $obj.clone1(CHAIN=> "{$alias}-s2c", DPORT => $port);
	                                        @rules_to_file.push: $test.argvec(1);
					} else {
						print "SPORT or DPORT not found - I got no clue where this rule should be going...";
					}
				}
			}
		}


		$!FileHandle.print("#---------- Create rules --------#\n");
		for @rules_to_file -> $elm {
			$!FileHandle.print($elm ~"\n");
		}
		$!FileHandle.say("#---------- End create rules --------#");
	}

	submethod GenerateUniqueChainNames {
		my %FromTo;

		# Generate an unique list of FromZone-ToZone, so that even though we use the same FromZone-ToZone more than once, it will only appear in the iptables-script once.
		for %!Rules.kv -> $from, @rules {
			for @rules -> $rule {
	                        my $to = $rule.key;
				%FromTo{$from ~ "-" ~ $to} = 1;
				%FromTo{$to ~ "-" ~ $from} = 1;
			}
		}


		$!FileHandle.print("#-------- Create zones ------\n");
		for %FromTo.keys -> $FromTo {
			$!FileHandle.print("iptables -N $FromTo\n");
		}
		$!FileHandle.print("#-------- End create zones ------\n\n");
	}

	submethod GenerateChains {
		my %ToBeCreatedNewLocal;
		my %ToBeCreatedAddLocal;

		my %ToBeCreatedNewRemote;
		my %ToBeCreatedAddRemote;

		for %!Rules.kv -> $from, @rules {
                	my $FromIp = $p5.invoke('NetAddr::IP','new', %!Zones{$from}{'ip'} ~ '/' ~ %!Zones{$from}{'cidr'});
                	for @rules -> $rule {
                	        my ($to, %options) = $rule.kv;
                	        my $protocol = %options<Protocol>;

                	        my ($name, $alias, $port, $proto) = $p5.call("CORE::getservbyname", $protocol, 'tcp');
                	        my $ToIp = $p5.invoke('NetAddr::IP','new',%!Zones{$to}{'ip'} ~ '/' ~ %!Zones{$to}{'cidr'});

#	         	        say "%FwcZones{$from}{'ip'} DNAT to %!Zones{$to}{'ip'}, port $port" unless $ToIp.contains($FromIp);
				print "Is local: ", %!Zones{$from}{'islocal'},"\n";
                	        if %!Zones{$to}{'islocal'} !~~ /true/ and %!Zones{$from}{'islocal'} !~~ /true/ {
                	                %ToBeCreatedAddRemote{"\$!FileHandle.print\(\"iptables -A FORWARD -i %!Zones{$from}{'interface'} -s $FromIp -o %!Zones{$to}{'interface'} -d $ToIp -j {$from}-{$to}\\n\"\)"} = 1;
                	                %ToBeCreatedAddRemote{"\$!FileHandle.print\(\"iptables -A FORWARD -i %!Zones{$to}{'interface'} -s $ToIp -o %!Zones{$from}{'interface'} -d $FromIp -j {$to}-{$from}\\n\"\)"} = 1;

                	        } else {
					print "From: ", $from,"\n";
					print "TO: ", $to,"\n";
					# Internal always needs to be at format: local-remote, remote-local - to/from does not matter

					print "local to: %!Zones{$to}{'islocal'}\n";
					print "local from: %!Zones{$from}{'islocal'}\n";
					my $zone1 = (%!Zones{$from}{'islocal'} ~~ /true/) ?? $from !! $to;
					my $zone2 = (%!Zones{$to}{'islocal'} ~~ /true/) ?? $from !! $to;
					print "{$zone1}-{$zone2}\n";
                	                %ToBeCreatedAddLocal{"\$!FileHandle.print\(\"iptables -A INPUT -i %!Zones{$to}{'interface'} -d $FromIp -j {$zone2}-{$zone1}\\n\"\)"} = 1;
                	                %ToBeCreatedAddLocal{"\$!FileHandle.print\(\"iptables -A OUTPUT -o %!Zones{$to}{'interface'} -s $ToIp -j {$zone1}-{$zone2}\\n\"\)"} = 1;
                	        }
                	}
        	}


		$!FileHandle.print("#-------- Add zone-chains(Remote) to chains ------\n");
		for %ToBeCreatedAddRemote.keys -> $line {
			EVAL($line);
		}
		$!FileHandle.print("#-------- End add zone-chains(Remote) to chains ------\n\n");



		$!FileHandle.print("#-------- Add zone-chains(Local) to chains ------\n");
		for %ToBeCreatedAddLocal.keys -> $line {
			EVAL($line);
		}
		$!FileHandle.print("#-------- End add zone-chains(Local) to chains ------\n\n");

	}
	submethod GenerateSpoofRules {
		my $file = "template/spoof.tmpl";
		my $spoofTemplate = try slurp($file);
                if ($!) {
                     note "Unable to open and read file, $file, $!";
                }

		$spoofTemplate ~~ s:g/\$IF\$/foo-interface/;
		$spoofTemplate ~~ s:g/\$SOURCE_IP\$/cool-ip2-cool/;

		$!FileHandle.print("#------------ Spoof - only allow certain ips to send and receive packets\n");
		$!FileHandle.print($spoofTemplate);
		$!FileHandle.print("#------------ End spoof - only allow certain ips to send and receive packets\n");
	}
	submethod GenerateClientServerProtoChains{
		my @ToBeCreated;
		my %UniqChainNames;

		for %!Rules.kv -> $from, @rules {
                	my $FromIp = $p5.invoke('NetAddr::IP','new', %!Zones{$from}{'ip'} ~ '/' ~ %!Zones{$from}{'cidr'});
                	for @rules -> $rule {
                	        my ($to, %options) = $rule.kv;
                	        my $protocol = %options<Protocol>;

	                        my ($name, $alias, $port, $proto) = $p5.call("CORE::getservbyname", $protocol, 'tcp');
	                        my $ToIp = $p5.invoke('NetAddr::IP','new',%!Zones{$to}{'ip'} ~ '/' ~ %!Zones{$to}{'cidr'});

				$alias = $protocol if $alias eq 0; # some alias doesn't exist, just use name given in policy-file

				%UniqChainNames{"{$alias}-s2c"} = $protocol;
				%UniqChainNames{"{$alias}-c2s"} = $protocol;

				@ToBeCreated.append( "\$!FileHandle.print\(\"iptables -A {$from}-{$to} -p tcp --dport $port -j {$alias}-c2s\\n\"\)" );
				@ToBeCreated.append( "\$!FileHandle.print\(\"iptables -A {$to}-{$from} -p tcp --sport $port -j {$alias}-s2c\\n\");" );
			}
		 }

		$!FileHandle.print("#-------- Create proto-client/server chains ------\n");
		for %UniqChainNames.keys -> $chainNames {
			$!FileHandle.print("iptables -N $chainNames\n");
		}

		$!FileHandle.print("#-------- End create proto-client/server chains ------\n\n");

		$!FileHandle.print("#-------- Append protos to proto-client/server chains ------\n");
		for @ToBeCreated -> $rule {
			 EVAL($rule);
		}
		$!FileHandle.print("#-------- End append protos to proto-client/server chains ------\n");



#		for %UniqChainNames.kv -> $chainNames,$protocol {
#			my @content = load_protocol($protocol);
#			if @content.elems > 0 {
#	                	say "Loaded protocol: ", @content.elems,"\n";
#				my @parsed_objs = map { $p5.invoke("IPTables::Rule","parser",split(' ', $_ ))}, @content;
#				for @parsed_objs -> $obj {
#	                        	my $test = $obj.clone1(CHAIN=> "{$alias}-c2s");
#	                                @rules_to_file.push: $test.argvec(1);
#	                        }
#	                }
#		}
	
#                $!FileHandle.print("#---------- Create rules --------#\n");
#                for @rules_to_file -> $elm {
#                        $!FileHandle.print($elm ~"\n");
#                }
#                $!FileHandle.say("#---------- End create rules --------#");

	}
}
